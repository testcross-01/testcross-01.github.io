<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>多线程 | Testcross</title><meta name="keywords" content="java"><meta name="author" content="testcross"><meta name="copyright" content="testcross"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程线程状态线程分为如下6种状态：  New（新创建）  Runnable（可运行）  Blocked（被堵塞）  Waiting（等待）  Timed waiting（计时等待）  Terminated（被终止）  新创建线程 当用new操作符创建一个新线程时，该线程处于new状态，并且还没有开始运行。在线程运行之前还有一些基础操作要做。 可运行线程一旦调用start方法，线程处于runnab">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="https://testcross-01.github.io/2020/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Testcross">
<meta property="og:description" content="多线程线程状态线程分为如下6种状态：  New（新创建）  Runnable（可运行）  Blocked（被堵塞）  Waiting（等待）  Timed waiting（计时等待）  Terminated（被终止）  新创建线程 当用new操作符创建一个新线程时，该线程处于new状态，并且还没有开始运行。在线程运行之前还有一些基础操作要做。 可运行线程一旦调用start方法，线程处于runnab">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://testcross-01.github.io/images/cover/xthHmnbdNerWOqP.png">
<meta property="article:published_time" content="2020-07-10T05:19:06.000Z">
<meta property="article:modified_time" content="2022-08-13T12:47:29.950Z">
<meta property="article:author" content="testcross">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://testcross-01.github.io/images/cover/xthHmnbdNerWOqP.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://testcross-01.github.io/2020/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-13 20:47:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/59674912?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/xthHmnbdNerWOqP.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Testcross</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-10T05:19:06.000Z" title="发表于 2020-07-10 13:19:06">2020-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-13T12:47:29.950Z" title="更新于 2022-08-13 20:47:29">2022-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程分为如下6种状态：</p>
<ul>
<li><p>New（新创建）</p>
</li>
<li><p>Runnable（可运行）</p>
</li>
<li><p>Blocked（被堵塞）</p>
</li>
<li><p>Waiting（等待）</p>
</li>
<li><p>Timed waiting（计时等待）</p>
</li>
<li><p>Terminated（被终止）</p>
<img src="/2020/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Image-16603831846241.png" class="" title="Image">
<h3 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h3><p> 当用new操作符创建一个新线程时，该线程处于new状态，并且还没有开始运行。在线程运行之前还有一些基础操作要做。</p>
<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行也可能没有，这取决于操作系统给线程提供运行的时间。<br>抢占调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。</p>
<h3 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h3><p>当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗较少的资源。直到线程调度器重新激活它。细节取决于它是增氧达到非活动状态。</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。</li>
<li>当线程等待另一个线程通知调度一条件时，它自己进入等待状态。实际上被阻塞状态于等待状态是有很大不同的。</li>
<li>有几个方法有一个超时参数。调用他们导致线程进入计时等待状态。这一状态将一直保持到超时期满或者接收到适当的通知。有超时参数的方法有Thread.sleep、Object.wait、Thread.jion、Lock.tryLock以及Condition.await的计时版。<h3 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h3>线程因如下两个原因之一而被终止：</li>
<li>因为run方法正常退出而自然死亡</li>
<li>因为一个没有捕获的异常终止了run方法而意外死亡。<br> 特别是，可以调用线程的stop方法杀死一个线程。该方法抛出一个ThreadDeath错误对象，由此杀死线程，stop方法已经弃用。</li>
</ul>
</li>
</ul>
<hr>
<p>   <em><strong>java.lang.Thread</strong></em></p>
<ul>
<li>void join() 等待终止指定的线程</li>
<li>Thread.State getState() 得到这一线程的状态</li>
<li>void stop() 停止该线程,已弃用</li>
<li>void suspend() 暂停该线程的执行，已弃用</li>
<li>void resume() 恢复线程,已弃用</li>
<li>void interrupt() 向线程发送中断请求。线程中断状态将被设置为true。如果该线程被一个sleep调用堵塞，呢吧抛出InterruptedException</li>
<li>static bolean inerrupted() 测试当前线程是否被中断，并重置为false</li>
<li>boolean isInterrupted() 测试线程是否终止.</li>
<li>static Thread currentThread() 返回代表当前执行线程的Thread对象<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2>讨论线程的各种属性，包括：线程优先级、守护线程、线程组以及处理为保护异常的处理器。<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3>java每个线程都有一个优先级。默认情况下，一个线程继承它的父线程的优先级。可以用setProiority方法提高或降低任何一个线程的优先级。<br>每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。线程优先级是高度依赖于系统，当虚拟机依赖于宿主平台的线程实现机制时，Java线程的优先级映射到宿主平台的优先级上，优先级个数也许更多，也许更少。（Windows有7个优先级别、Linux优先级会被忽略）<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3>守护线程（daemom thread）的唯一用途是未其他线程提供服务。当只剩下守护线程时，虚拟机就退出了。<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3>线程的run方法不能抛出任何被检查的异常，但是，不被检查的异常会导致线程终止。在这种情况下，线程就死亡了。<br>处理器必须包含一个实现Thread.UncaughtExceptionHandler接口的类。这个接口只有一个方法。<br>void uncaughtException(Thread t,Throwable e)<br>但是，不需要任何catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。可以通过setUncaughtExceptionHandler方法未任何线程安装一个处理器。也可以利用静态方法setDefaultUncaughtExceptionHandler未所有线程安装一个默认的处理器。<br>ThreadGroup类实现Thread.UncaughtExceptionHandler接口。他的uncaughtException方法操作如下：</li>
</ul>
<p>   1.如果该线程组有父线程组，那么浮现出组的此方法被调用。<br>   2.否则，getDefaultUncaughtExceptionHandler如果返回一个非空处理器，调用该处理器。<br>   3.否则，如果Throwable是ThreadDeath的一个实例，什么都不做。<br>   4.否则，线程的没准以及Throwable的栈轨迹被输出到System.err上。</p>
<hr>
<p>   <em><strong>java.lang.Thread</strong></em></p>
<ul>
<li>void setPriority(int newPriority) 设置线程的优先级。</li>
<li>static void yield() 导致当前线程处于让步状态。如果有其他的可运行具有至少比此线程同样高的优先级，那么这些线程接下来会被调度。</li>
<li>static void setDefaultUncaughtExceptionHandler(Thread.Uncau ghtExceptionHandler handler) <ul>
<li>static void Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(Thread.Uncau ghtExceptionHandler handler)<br>设置或获取未包含异常的默认处理器</li>
</ul>
</li>
<li>setUncaughtExceptionHandler\getUncaughtExceptionHandler<br> 设置或获取未捕获异常的处理器。如果没安装处理器，则将线程对象作为处理器。<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2>根据各线程访问数据的次序，可能会产生讹误的情况，这样一个情况通常被称为竞争条件（race condition）。<h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3>Java SE 5.0引入ReentrantLock类，锁结构确保任何时候只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。<br>锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（hold count）来耿总对lock方法的嵌套调用。线程每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代买可以调用另一个使用相同的锁的方法。<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3>通常，线程进入临界区，却发现在某一条件满足之后才能执行。要使用一个条件管理对象来管理那些已经获得了一个锁但却不能做有用工作的线程。<br>一个锁对象可以有一个或多个相关的条件对象。通过newCondition方法获得提供条件对象。调用awiat方法使得当前线程被阻塞并且放弃了锁。<br>等待获得锁的线程和调用await方法的线程存在在本质上的不同。一旦一个线程调用awiat方法，它将进入等待集。当锁能用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法时为止。一旦锁成为可用的，它们中的某个将从await调用返回，获得该锁并从阻塞的地方继续执行。</li>
</ul>
<hr>
<p>   <em><strong>java.util.concurrent.locks.Lock</strong></em></p>
<ul>
<li>void lock() 获得这个锁；如果锁同时被另一个线程拥有则发生堵塞</li>
<li>void unlock() 释放这个锁</li>
<li>Condition newCondition() 返回一个跟该锁相关的条件对象</li>
</ul>
<hr>
<p> <em><strong>java.util.concurrent.locks.Condition</strong></em></p>
<ul>
<li>void await() 将该线程放到条件的等待集中</li>
<li>void signalAll() 解除该条件的等待集中的所有线程的阻塞状态</li>
<li>void signal() 从该条件等待集中随机选取一个线程，解除其堵塞状态<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3>从1.0版开始，Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须说的内部的对象锁。<br>内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法接触等待线程的阻塞状态。换句话说，调用wait或notifyAll等价于await和signalAll。<br>将静态方法声明未synchronized也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。<br>内部锁和条件存在一些局限。包括：</li>
<li>不能中断一个正在视图获得锁的线程。</li>
<li>视图获得锁时不能设定超时。</li>
<li>每个锁仅有单一的条件。</li>
</ul>
<hr>
<p><em><strong>java.lang.Object</strong></em></p>
<ul>
<li>void notifyAll() 解除那些在该对象调用wait方法的线程的阻塞状态</li>
<li>void notify() 随机选择一个在该对象上调用wait方法的线程</li>
<li>void wait() 导致线程进入等待状态直到它被通知<h3 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h3>每一个Java对象有一个锁，线程可以通过调用同步方法获得锁。还有另一种机制可以获得同步锁，进入一个同步阻塞。<br>有时程序员使用一个对象的锁实现额外的原子操作，实际上称为客户端锁定。客户端锁定利用修改的对象为锁对象，但必须确保所有的修改都使用内部锁，否则任然可能有其他操作对其修改，所以客户端锁是非常脆弱的，通常不推荐使用。<h3 id="监视器概念"><a href="#监视器概念" class="headerlink" title="监视器概念"></a>监视器概念</h3>监视器具有如下特征：</li>
<li>监视器是只包含私有域的类。</li>
<li>每个监视器类的对象有一个相关的锁。</li>
<li>使用该锁对所有的方法进行加锁。</li>
<li>该锁可以有任意多个相关条件。<br>Java内部锁实现的不同</li>
<li>域不要必须是private。</li>
<li>方法不要求必须是synchronized。</li>
<li>内部锁对客户是可用的。<h3 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h3>现代多处理器计算机和编译器决定了非同步的方法，出错的可能性很大。<ul>
<li>多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值。</li>
<li>编译器可以改变指令执行的顺序以是吞吐量最大化。<br>volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。<br>volatile无法提供原子性。<blockquote>
<p>Brian Goetz给出了下述“同步格言”：“如果向一个变量写入值，而中国变量接下来可能会被另一个线程读取，或者，从一个变量读值，而这个变量可能是之前另一个线程写入的，此时必须使用同步方法”。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p>  域声明为final是可以安全地访问一个共享域。不使用final其他线程看到的变量是更新后的值，域声明final要在构造函数完成构造之后才能看到。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>  java.util.concurrent.atomic包中有很多类使用了很搞笑的机器级指令来确保其他操作的原子性。包中包含AutomicIntegar、AtomicBoolean、AtomicLong和AtomicReference以及其对于的原子数组。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>  Java语言没有任何东西可以避免或搭配这种死锁现象。必须仔细涉及程序，以确保包含出现死锁。</p>
<h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>  ThreadLocal辅助类为各个线程提供单独的实例。</p>
<hr>
<p>  <em><strong>java.lang.ThreadLocal<T></strong></em></p>
<ul>
<li>T get() 得到这个线程的当前值。如果是首次调用get，会调用initialize来得到这个值。</li>
<li>protectted initialize() 应覆盖整个方法来提供一个初始值。默认返回null。</li>
<li>void set(T t) 为这个线程设置一个新值.</li>
<li>void remove() 删除对应这个线程的值。<h3 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h3>tryLock方法视图申请一个锁，在获得锁后返回true，否则，立即返回false，而且线程可以立即离开去做其他事情。<br>如果调用带有超时参数的tryLock，如果线程在等待期间被中断，将抛出InterruptedException异常。<br>也可以调用lockInterruptibly方法，相当于一个超时设为无限的tryLock方法。<br>在等待一个条件时，也可以提供一个超时。</li>
</ul>
<hr>
<p>   <em><strong>java.util.concurrent.locks.Lock</strong></em></p>
<ul>
<li>void tryLock() 尝试获得锁而没有发生堵塞。</li>
<li>void tryLock(long time,TimeUnit unit) 场是获得锁，阻塞时间包含超过给定的值。</li>
<li>void lockInterruptibly()  获得锁，但是包确定地发生阻塞。</li>
</ul>
<hr>
<p> <em><strong>java.util.concurrent.locks.Condition</strong></em></p>
<ul>
<li>boolean await(long time,TimeUnit unit) 进入该条件的等待集，直到线程从等待集中移出或等待了指定的时间之后才解除阻塞。<h3 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读/写锁"></a>读/写锁</h3></li>
<li><strong>java.util.concurrent.locks.ReentrantReadWriteLock</strong>*</li>
<li>Lock readLock() 得到一个可以被多个读操作共用的读锁，但会排斥所有写操作。</li>
<li>Lcok writeLock() 得到一个写锁，排斥所有其他的读操作和写操作。<h3 id="stop和suspend方法弃用"><a href="#stop和suspend方法弃用" class="headerlink" title="stop和suspend方法弃用"></a>stop和suspend方法弃用</h3>stop方法终止所有未结束的方法，并立即释放被它所著的所有对象的锁。这会导致对象处于不一致的状态，当线程要终止另一个线程是，无法直到什么时候调用stop方法是安全的，什么时候导致对象被破坏，因此，该方法被弃用了。<br>suspend方法挂起时不会释放锁，所有该锁在恢复之前是不可用的。如果调用suspend方法的线程视图获得同一个锁，那么出现死锁。所以suspend方法会经常出现死锁的情况。<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2>生产者线程向队列插入元素，消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。<br>试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列导致线程阻塞。队列会自动地平衡负载，如果第一个线程集比第二个慢，第二个线程集在等待结果时会堵塞。如果第一个线程集运行得块，它将等待第二个队列集赶上来。<br>如果将队列当作线程管理工具来使用，将要用到put和take方法。</li>
<li><strong>java.util.concurrent.ArrayBlockingQueue<E></strong>*</li>
<li><strong>java.util.concurrent.LinkedBlockingQueue<E></strong>*</li>
<li><strong>java.util.concurrent.LinkedBlockingDeque<E></strong>*</li>
<li><strong>java.util.concurrent.DelayQueue<E></strong>*   <em><strong>java.util.concurrent.Delayed</strong></em></li>
<li><strong>java.util.concurrent.PriorityBlockingQueue<E></strong>*</li>
<li><strong>java.util.concurrent.BlockingQueue<E></strong>* </li>
<li><strong>java.util.concurrent.BlockingDeque<E></strong>* </li>
</ul>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><h3 id="高效的映射表、集合和队列"><a href="#高效的映射表、集合和队列" class="headerlink" title="高效的映射表、集合和队列"></a>高效的映射表、集合和队列</h3><p>  java.util.concurrent包提供了映射表、有序集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue<br>  集合返回弱一致性（weakly consistent）的迭代器。这意味着迭代器不一定能反应出它们被构造之后的所有修改，但是，它们不会将同一个值返回两次，也不会抛出ConcurrentModificationException异常。<br>  并发的散列映射表，可以高效的支持大量的读者和一定数量的写者。默认情况下，假定可以有多达16个写者线程同时执行。<br>  putIfAbsent方法自动地添加新的关联，前题是原来没有这一关联。<br>  相反的操作是删除removeIfPresent。<br>  replace原子性地用新值替换旧值，假定旧值域指定的键值关联。</p>
<h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><p>  CopyOnWriteArrayList和CopyOnWriteArraySet所有的修改线程对底层数组进行复制。“快照”样式迭代器方法在创建迭代器的时候使用对数组状态的引用。</p>
<h3 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h3><p>  从Java初始版本开始，Vector和Hashtable类就提供了线程安全的动态数组和散列表的实现。现在这些类被启用了，取而代之的是ArrayList和HashMap类，但这些类不是线程安全的。<br>  任何集合类可以通过使用同步包装器编程线程安全的。</p>
<h2 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h2><p>  Callable与Runnable类似，但是有返回值。类型参数就是返回值的类型。<br>  Future保存异步计算的结果。Future对象的所有者在结果计算好之后就可以获得它。<br>  FutureTak包装器可以将Callable转换成Future和Runnable，它同时实现二者的接口。<br><em><strong>java.util.concurrent.Callable<V></strong></em></p>
<ul>
<li>V call() 运行一个产生结果的任务。</li>
<li><strong>java.util.concurrent.Future<V></strong>*</li>
<li>V get()</li>
<li>V get(long time,TimeUnit unit) 获取结果，如果没有结果可用，则堵塞直到真正得到结果超锅指定的时间为止。如果不成功，第二个方法会抛出TimeoutException</li>
<li>boolean cancel(bolean mayInterrupt) 尝试取消这一任务。如果任务已经开始，并且mayInterrupt参数为true，它就被中断。</li>
<li>boolean isCancelled() 如果任务在完成前取消了，则返回ture。</li>
<li>boolean isDone() 如果任务结束，无论什么方式，都返回true。<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2>如果线程中创建了大量的生命周期很短的线程，一个使用线程池（thread pool）。一个线程池包含许多准备运行的空闲线程。将Runnable对象交给线程池，就会有一个线程调用run方法。当run方法退出时，线程不会死亡，而是在池中准备为下一个请求提供帮助。<br>执行器类有许多静态工厂方法用来构建线程池。</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p> newCachedThreadPool构建一个线程池，对于每个人物，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，创建一个新线程。<br>newFixedThreadPool创建固定大小的线程池。如果提交任务多余空闲的线程数，那把得不到服务的任务放置在队列中。newSingleThreadExecutor<br>是一个退化了的大小为1的线程池：由一个线程执行提交的任务，一个接着一个。<br>    3给方法返回实现了ExecutorService接口的ThreadPoolExecutor类的对象。<br>  利用以下三种方法将一个Runnable对象或Callable对象提交给ExecutorService。  </p>
<ul>
<li>Future&lt;?&gt;submit(Runnable task)</li>
<li>Future<T>submit(Callable<T> task)</li>
<li>Future<T>submit(Runnable task, T result）<br>使用链接池的步骤</li>
</ul>
<p>1.调用Executors类中静态方法newCachedThreadPool或newFixedThreadPool。<br>2.调用submit提交Runnable或Callable对象。<br>3.如果想取消一个任务，或人工提交Callable对象，那就要保存号返回的Future对象。<br>4.当不再提交任何任务时，调用shutdown。</p>
<hr>
<p><em><strong>java.util.concurrent.Executors</strong></em></p>
<ul>
<li>ExecutorService newSingleThreadExecutor() </li>
<li>ExecutorService newCachedThreadPool() 返回一个带缓存的线程池，该池再必要时创建线程，再线程空闲60秒之后终止线程。</li>
<li>ExecutorService newFixedThreadPool() 返回一个线程池，该池中的线程数由参数决定。</li>
<li><strong>java.util.concurrent.ExecutorService</strong>*</li>
<li>Future&lt;?&gt;submit(Runnable task)</li>
<li>Future<T>submit(Callable<T> task)</li>
<li>Future<T>submit(Runnable task, T result）<br>提交任务去执行</li>
<li>void shutdown() 关闭服务，会先完成已经提交的任务而不再接收新的任务。</li>
<li><strong>java.util.concurrent.ThreadPoolExecutor</strong>*</li>
<li>int getLargestPoolSize()返回在池中同时进行的最大线程数。</li>
</ul>
<h3 id="预定执行"><a href="#预定执行" class="headerlink" title="预定执行"></a>预定执行</h3><p>  ScheduledExecutorService接口具有为预定执行或重复执行任务而设计的方法。它是一种运行线程池机制的java.uti.Timer的泛化。<br>  可用预定Runnable或Callable再初始的延迟之后只执行异常。也可以预定一个Runnable对象周期的运行。<br>  </p>
<h3 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h3><p>  利用执行器来控制一组相关任务。<br>  <br>  </p>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork-Join框架"></a>Fork-Join框架</h3><p>  Fork/Join 框架是 Java7 提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>  在后台，fork-join框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取（work stealing）。每个工作线程都由一个双端队列来完成任务。一个工作线程将子任务压入器双端队列的队头。一个工作线程空闲时，它就会从双端对垒的队尾“密取”一个任务。由于大的子任务都在队尾，这种密取很少出现。</p>
<h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><p>  java.util.concurrent包包含了几个能帮助入门管理相互合作的线程集的类。这些机制具有为线程之间的共用集结点提供的”预置功能“</p>



<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>   一个信号量管理许多许可证（permits）。未来通过信号量，线程通过调用acquire请求许可。实际上信号量维护一个技术，许可的数目是固定的，由此现在通过的线程数量。线程通过调用acquire请求许可，通过调用release释放许可。</p>
<h3 id="倒计时门栓"><a href="#倒计时门栓" class="headerlink" title="倒计时门栓"></a>倒计时门栓</h3><p>  一个倒计时门栓让一个线程等待直到计数变为0。倒计时门栓是一次性的，一旦计数为0，就不能再重用了。</p>
<h3 id="障栅"><a href="#障栅" class="headerlink" title="障栅"></a>障栅</h3><p>  CyclicBarrier类实现了一个集结点（rendezvous）称为（barrier）。考虑大量线程运行再一次计算的不同部分的情况。当所有部分都准备好时，需要把结果组合再一起。当一个线程完成了它的那部分任务后，我们让他运行到障栅处。一旦所有线程都到达了这个障栅，障栅就撤销，线程就可以继续运行。</p>
<h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p>  当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器（Exchanger）。典型的情况是，一个线程向缓冲区填入数据，另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>  同步队列是一种将森缠着与消费者线程配对的机制。当一个线程调用同步队列的put方法，它会阻塞直到另一个线程调用take方法位置，反之亦然。<br>  从概念上讲，它不是一个队列，它根本没有包含任何元素，它的size方法总返回0。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://testcross-01.github.io">testcross</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://testcross-01.github.io/2020/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">https://testcross-01.github.io/2020/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://testcross-01.github.io" target="_blank">Testcross</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/xthHmnbdNerWOqP.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/06/deep_learning/"><img class="prev-cover" src="/images/cover/53eTB2uiNRlXwFP.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">deep-learning</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/27/%E5%86%85%E9%83%A8%E7%B1%BB/"><img class="next-cover" src="/images/cover/bEJsXxewpOGuRD8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">内部类</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/06/27/%E5%86%85%E9%83%A8%E7%B1%BB/" title="内部类"><img class="cover" src="/images/cover/bEJsXxewpOGuRD8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-27</div><div class="title">内部类</div></div></a></div><div><a href="/2020/06/23/%E5%8F%8D%E5%B0%84/" title="反射"><img class="cover" src="/images/cover/xthHmnbdNerWOqP.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-23</div><div class="title">反射</div></div></a></div><div><a href="/2020/06/27/%E9%9B%86%E5%90%88/" title="集合"><img class="cover" src="/images/cover/T7Mu8Aod3egmC4Q.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-27</div><div class="title">集合</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/59674912?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">testcross</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/testcross-01"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/testcross-01" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:testcross0802@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">testcross的blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">新创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">可运行线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">被阻塞线程和等待线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E7%BB%88%E6%AD%A2%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">被终止的线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">线程属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">未捕获异常处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">锁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">条件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">synchronized关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E"><span class="toc-number">1.3.4.</span> <span class="toc-text">同步阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.5.</span> <span class="toc-text">监视器概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile%E5%9F%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">Volatile域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.7.</span> <span class="toc-text">final变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.3.8.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.9.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.10.</span> <span class="toc-text">线程局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="toc-number">1.3.11.</span> <span class="toc-text">锁测试与超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB-%E5%86%99%E9%94%81"><span class="toc-number">1.3.12.</span> <span class="toc-text">读&#x2F;写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stop%E5%92%8Csuspend%E6%96%B9%E6%B3%95%E5%BC%83%E7%94%A8"><span class="toc-number">1.3.13.</span> <span class="toc-text">stop和suspend方法弃用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.5.</span> <span class="toc-text">线程安全的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E6%98%A0%E5%B0%84%E8%A1%A8%E3%80%81%E9%9B%86%E5%90%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">高效的映射表、集合和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.2.</span> <span class="toc-text">写数组的拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%83%E6%97%A9%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.5.3.</span> <span class="toc-text">较早的线程安全集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callable%E4%B8%8EFuture"><span class="toc-number">1.6.</span> <span class="toc-text">Callable与Future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">执行器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.7.1.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E6%89%A7%E8%A1%8C"><span class="toc-number">1.7.2.</span> <span class="toc-text">预定执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BB%BB%E5%8A%A1%E7%BB%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">控制任务组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-Join%E6%A1%86%E6%9E%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">Fork-Join框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E6%A0%93"><span class="toc-number">1.8.2.</span> <span class="toc-text">倒计时门栓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%9C%E6%A0%85"><span class="toc-number">1.8.3.</span> <span class="toc-text">障栅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">交换器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">1.8.5.</span> <span class="toc-text">同步队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">1.9.</span> <span class="toc-text">附录</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/13/String/" title="String"><img src="/images/cover/xthHmnbdNerWOqP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="String"/></a><div class="content"><a class="title" href="/2022/08/13/String/" title="String">String</a><time datetime="2022-08-13T09:45:10.234Z" title="发表于 2022-08-13 17:45:10">2022-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/11/test/" title="test"><img src="/images/cover/53eTB2uiNRlXwFP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="test"/></a><div class="content"><a class="title" href="/2022/08/11/test/" title="test">test</a><time datetime="2022-08-11T03:17:59.000Z" title="发表于 2022-08-11 11:17:59">2022-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/06/deep_learning/" title="deep-learning"><img src="/images/cover/53eTB2uiNRlXwFP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="deep-learning"/></a><div class="content"><a class="title" href="/2022/08/06/deep_learning/" title="deep-learning">deep-learning</a><time datetime="2022-08-06T07:03:06.000Z" title="发表于 2022-08-06 15:03:06">2022-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><img src="/images/cover/xthHmnbdNerWOqP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/2020/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程">多线程</a><time datetime="2020-07-10T05:19:06.000Z" title="发表于 2020-07-10 13:19:06">2020-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/27/%E5%86%85%E9%83%A8%E7%B1%BB/" title="内部类"><img src="/images/cover/bEJsXxewpOGuRD8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内部类"/></a><div class="content"><a class="title" href="/2020/06/27/%E5%86%85%E9%83%A8%E7%B1%BB/" title="内部类">内部类</a><time datetime="2020-06-27T06:06:42.000Z" title="发表于 2020-06-27 14:06:42">2020-06-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By testcross</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>